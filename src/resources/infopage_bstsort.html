<!DOCTYPE HTML>  
 
 <html> 

    <head>
    </head>
    <body>
    <h2>About Binary Tree Sort (BST)</h2></br>
    
    <table border="0" align="left">
  	<tr>
 		<th align="left">Worst case </br>performance</th>
 		<td><p>O(<i>n</i>²) (unbalanced)</p></td>
 		<td><p>O(<i>n</i> log <i>n</i>) (balanced)</p></td>
    </tr>
    <tr>
   		<th align="left">Best case </br>performace</th>
   		<td><p>O(<i>n</i>) (unbalanced)</p></td>
   		<td><p>O(<i>n</i> log <i>n</i>) (balanced)</p></td>
  	</tr>
  	<tr>
    	<th align="left">Average case </br>performance</th>
    	<td><p>O(<i>n</i> log <i>n</i>)</p></td>
  	</tr>
  	<tr>
    	<th align="left">Worst case space </br>complexity</th>
    	<td>O(<i>n</i>)</td>
  	</tr>
  	
	</table>
	
	
	</br></br></br></br></br></br></br></br></br></br></br></br></br></br>
	<h2>Abstract</h2>
	<p>Adding one item to a binary search tree is on average an O(log n) process (in big O notation), so adding n items is an O(n log n) process, making tree sort a so-called 'fast sort'. 
	But adding an item to an unbalanced binary tree needs O(n) time in the worst-case, when the tree resembles a linked list (degenerate tree), causing a worst case of O(n²) for this sorting algorithm. This worst case occurs when the algorithm operates on an already sorted set, or one that is nearly sorted. 
	Expected O(log n) time can however be achieved in this case by shuffling the array.
	</p></br></br>
	<p>Informations from <a href="http://en.wikipedia.org/wiki/Quicksort"><i>Wikipedia</i></a></p>
    
    </body>
 </html> 