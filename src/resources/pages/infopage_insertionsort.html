<!DOCTYPE HTML>  
 
 <html>
    <body>
    <h2>Complexity</h2>
    
    <table border="0">
  	<tr>
 		<th align="left">Worst case </br>performance</th>
 		<td><p>O(<i>n</i><sup>2</sup>) comparisons, swaps</p></td>
    </tr>
    <br>
   		<th align="left">Best case </br>performance</th>
        <td><p>O(<i>n</i>) comparisons</p></td>
   		<td><p>O(1) swaps</p></td>
  	</tr>
  	<tr>
    	<th align="left">Average case </br>performance</th>
        <td><p>O(<i>n</i><sup>2</sup>) comparisons, swaps</p></td>
  	</tr>
  	<tr>
    	<th align="left">Worst case space </br>complexity</th>
    	<td>O(<i>n</i>) total, O(1) auxiliary</td>
  	</tr>
	</table>
	
	<h2>Abstract</h2>
	<p>Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time.
        At each iteration insertion sort removes on element from the unsorted list and <b>finds the correct
            position</b> on the already sorted list. This repeats until no elements from the unsorted list are left.
        Insertion sort is <b>less efficient on large lists</b> than more advanced algorithms such as quick sort, heapsort, or merge sort.
        However, insertion sort appears to be <b>faster on small lists of elements</b> (usually between 7 and 50 elements) than those algorithms.
        Therefore it is <b>useful in the optimization of other algorithms</b>, when the list size is below a certain threshold.
	</p>

    <h2>Related</h2>

    <ul>
        <li><a href="infopage_selectionsort.html">Selection sort</a> </li>
        <li><a href="infopage_shellsort.html">Shell sort</a> </li>
    </ul>
	<p>Information from <a href="http://en.wikipedia.org/wiki/Insertionsort"><i>Wikipedia</i></a></p>
    </body>
 </html> 