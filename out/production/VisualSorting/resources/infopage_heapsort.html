<!DOCTYPE HTML>  
 
 <html> 

    <head>
    </head>
    <body>
    <h2>About Heapsort</h2></br>
    
    <table border="0" align="left">
  	<tr>
 		<th align="left">Worst case </br>performance</th>
 		<td><p>O(<i>n</i> log <i>n</i> )</p></td>
    </tr>
    <tr>
   		<th align="left">Best case </br>performace</th>
   		<td><p>O(<i>n</i> log <i>n</i> ) (simple partition) </br> 
   		or O(<i>n</i>) (three-way partition and equal keys)</p></td>
  	</tr>
  	<tr>
    	<th align="left">Average case </br>performance</th>
    	<td><p>O(<i>n</i> log <i>n</i> )</p></td>
  	</tr>
  	<tr>
    	<th align="left">Worst case space </br>complexity</th>
    	<td>O(1) auxiliary</td>
  	</tr>
  	
	</table>
	
	
	</br></br></br></br></br></br></br></br></br></br></br></br></br></br>
	<h2>Abstract</h2>
	<p>The heapsort algorithm can be divided into two parts.
	In the first step, a heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree. 
	The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node's parent, left child branch, or right child branch are simple expressions. 
	For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then
	</p></br></br>
	<p>Informations from <a href="http://en.wikipedia.org/wiki/Quicksort"><i>Wikipedia</i></a></p>
    
    </body>
 </html> 