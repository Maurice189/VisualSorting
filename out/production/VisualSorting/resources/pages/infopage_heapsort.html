<!DOCTYPE HTML>  
 
 <html>
    <body>
    <h2>Complexity</h2>
    
    <table border="0">
  	<tr>
 		<th align="left">Worst case </br>performance</th>
 		<td><p>O(<i>n</i> log <i>n</i> )</p></td>
    </tr>
    <tr>
   		<th align="left">Best case </br>performance</th>
   		<td><p>O(<i>n</i> log <i>n</i> )</p></td>
  	</tr>
  	<tr>
    	<th align="left">Average case </br>performance</th>
    	<td><p>O(<i>n</i> log <i>n</i> )</p></td>
  	</tr>
  	<tr>
    	<th align="left">Worst case space </br>complexity</th>
    	<td>O(1) auxiliary</td>
  	</tr>
  	
	</table>

	<h2>Abstract</h2>
	<p>The heapsort algorithm can be divided into two parts.
        In the first step, a <b>heap is built out of the data</b>. The heap is often placed in an array with the layout of a complete binary tree.
        Afterwards in every iteration the <b>minimum element within the heap is removed</b> (<i>extract min</i>) and added
        to the already sorted part. Since this operation only takes O(log <i>n</i>) it can be seen as an improvement of
        selection sort. Although heap sort is an <b>in-place algorithm
        it is not stable</b> in its original implementation. Compared to other fast algorithms like quick sort,
        heap sort has the <b>favorable O(<i>n</i> log <i>n</i>) worst case complexity</b>. Though in concrete implementations
        <b>heap sort is slower than quick sort</b>, due to its high constant complexity factors that are "hidden" within
        the O-notation.
    </p>

    <h2>Related</h2>

    <ul>
        <li><a href="infopage_selectionsort.html">Selection sort</a> </li>
    </ul>
	<p>Information from <a href="http://en.wikipedia.org/wiki/Quicksort"><i>Wikipedia</i></a></p>

    </body>
 </html> 